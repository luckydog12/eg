<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      "use strict"
      // 非严格模式下
      var a = 10
      function fn() {
        console.log(this)
      }
      // 由于调用fn的位置处于全局，所以此时this指向window，便会找到使用var定义在全局下的a变量，输出10
      fn()

      // this一旦被确定，就不可以再更改
      // var obj = { a: 20 }
      // function fn1() {
      //   this = obj // 报错
      //   console.log(this.a)
      // }
      // fn1()

      // // 作为某个对象的方法调用，this指向上级对象,谁调用，指向谁
      // function fn2() {
      //   console.log(this.b) // this指向obj1
      // }
      // var obj1 = { b: 1, c: fn2 }
      // obj1.c()

      // // 构造函数 new改变this指向实例对象
      // function Fn3() {
      //   console.log(this)
      //   this.d = 1
      // }
      // var obj2 = new Fn3()
      // console.log(obj2.d) // 1

      // apply() call() bind() 它们的第一个参数可改变this指向
      // 箭头函数中的this指向上一层作用域（父级）
    </script>
  </body>
</html>
